#include "main.h"

/**
    * C -50.0,0,20 0,0,1 70
    ∗ identifier: C
    ∗ x,y,z coordinates of vp: -50.0, 0, 20
    ∗ x,y,z normalized orientation vector: 0, 0, 1
    ∗ field of view: 70 (in degrees)
 */
camera_t
*camera_guard(char **split, int line)
{
    camera_t    *res;
    char        **pos;
    char        **direction;

    if (split_len(split) != 4)
        throw_error("Invalid camera arguments at line: ", line, NULL);
    res = new_(sizeof(camera_t));

    pos = ft_split(split[1], ",");
    if (split_len(pos) != 3)
        throw_error("Invalid position in line: ", line, split[1]);

    res->pos.x = double_guard(pos[0], line, DOUBLE_MIN, DOUBLE_MAX);
    res->pos.y = double_guard(pos[1], line, DOUBLE_MIN, DOUBLE_MAX);
    res->pos.z = double_guard(pos[2], line, DOUBLE_MIN, DOUBLE_MAX);

    direction = ft_split(split[2], ",");
    if (split_len(direction) != 3)
        throw_error("Invalid direction in line: ", line, split[2]);
    res->direction.x = double_guard(direction[0], line, -1, 1);
    res->direction.y = double_guard(direction[1], line, -1, 1);
    res->direction.z = double_guard(direction[2], line, -1, 1);

    res->fov = ft_atoi(split[3]);

    // if (DEBUG)
    // {
    //     printf(YELLOW"Camera: \n"RESET);
    //     printf("\tpos: %f, %f, %f\n", res->pos.x, res->pos.y, res->pos.z);
    //     printf("\tdirection: %f, %f, %f\n", res->direction.x, res->direction.y, res->direction.z);
    //     printf("\tfov: %d\n", res->fov);
    // }

    return (res);
}
#include "tools.h"

// color_t extract_color(char *line)
// {
//     color_t color;


// }

// bool is_color(char *color)
// {
    
// }#include "main.h"

/**
 * cy 50.0,0.0,20.6 0.0,0.0,1.0 14.2 21.42 10,0,255
 * identifier: cy
 * coordinates of the center: 50.0,0.0,20.6
 * normalized orientation vector: 0.0,0.0,1.0 [-1, 1]
 * diameter: 14.2 [0, inf]
 * height: 21.42 [0, inf]
 * color: 10,0,255
 */
cylinder_t
*cylander_guard(char **split, int line)
{
    cylinder_t *res;

    if (split_len(split) != 6)
        throw_error("Invalid cylinder arguments at line: ", line, NULL);

    res = new_(sizeof(cylinder_t));

    res->pos = point_guard(split[1], line);
    res->normal = point_guard(split[2], line);
    res->diameter = double_guard(split[3], line, 0, DOUBLE_MAX);
    res->height = double_guard(split[4], line, 0, DOUBLE_MAX);
    res->color = color_guard(split[5], line);

    res->next = NULL;

    // if (DEBUG)
    // {
    //     printf(YELLOW"Cylinder: \n"RESET);
    //     printf("\tpos: %f, %f, %f\n", res->pos.x, res->pos.y, res->pos.z);
    //     printf("\tnormal: %f, %f, %f\n", res->normal.x, res->normal.y, res->normal.z);
    //     printf("\tdiameter: %f\n", res->diameter);
    //     printf("\theight: %f\n", res->height);
    //     printf("\tcolor: %d, %d, %d\n", res->color.r, res->color.g, res->color.b);
    // }

    insert_cylinder(res);
    return (res);
}
#include "main.h"

void    throw_error(char *msg, int line, char *add)
{
    size_t  size;

    ft_putstr_fd(RED"Error\n"RESET, STDERR_FILENO);
    size = ft_strlen(msg) + ft_strlen(ft_itoa(line));
    ft_putstr_fd("+", STDERR_FILENO);
    while (size--)
        ft_putstr_fd("-", STDERR_FILENO);
    ft_putstr_fd("+\n", STDERR_FILENO);
    if (add)
    {
        ft_putstr_fd("|", STDERR_FILENO);
        ft_putstr_fd(add, STDERR_FILENO);
        size = ft_strlen(add);
        while ((size++) < (ft_strlen(msg) + ft_strlen(ft_itoa(line))))
            ft_putstr_fd(" ", STDERR_FILENO);
        ft_putstr_fd("|\n", STDERR_FILENO);
    }
    ft_putstr_fd("|", STDERR_FILENO);
    ft_putstr_fd(msg, STDERR_FILENO);
    if (line != -1)
        ft_putnbr_fd(line, STDERR_FILENO);
    ft_putstr_fd("|\n", STDERR_FILENO);
    size = ft_strlen(msg) + ft_strlen(ft_itoa(line));
    ft_putstr_fd("+", STDERR_FILENO);
    while (size--)
        ft_putstr_fd("-", STDERR_FILENO);
    ft_putstr_fd("+\n", STDERR_FILENO);
    clean_();
    exit(1);
}
#include "main.h"

#ifdef __linux__
    enum e_keys
    {
        ESC = 65307,
    };
#endif

#ifdef __APPLE__
    enum e_keys
    {
        ESC = 53,
    };
#endif

int	event_mapper(int keycode)
{

    if (keycode == ESC)
    {
        mlx_destroy_window(*mlx(), *mlx_win());
        clean_();
        exit(0);
    }

	printf("Keycode: %d\n", keycode);
	return (0);
}

void    events()
{
    mlx_key_hook(*mlx_win(), event_mapper, NULL);
}
#include "main.h"

double  dist(space_point_t *p1, space_point_t *p2)
{
    return (sqrt(
        pow(p2->x - p1->x, 2) + pow(p2->y - p1->y, 2) + pow(p2->z - p1->z, 2)
    ));
}

bool    is_in_fov(space_point_t *center)
{   
    double          angle_between;
    camera_t        *camera;

    camera = scene()->camera;
    // arccos( ( (CD^2) + (CP^2) - (PD ^ 2) ) / (2 * CD * CP) )
    angle_between = acos(
        (
            pow(dist(&camera->pos, &camera->direction), 2) +
            pow(dist(&camera->pos, center), 2) -
            pow(dist(center, &camera->direction), 2)
        )
        /
        (
            2*
            dist(&camera->pos, &camera->direction) *
            dist(&camera->pos, center)
        )
    );

    angle_between *= 180 / M_PI;

    if (angle_between < (camera->fov / 2))
        return true;

    return false;
}

#include "main.h"

gc_t **local_gc()
{
    static gc_t *gc = NULL;
    return (&gc);
}

void *new_(size_t size)
{
    gc_t *gc;
    gc_t *iter;

    gc = malloc(sizeof(gc_t));
    if (!gc)
        throw_error("malloc failed", -1, NULL);
    gc->ptr = malloc(size);
    if (!gc->ptr)
    {
        free(gc);
        throw_error("malloc failed", -1, NULL);
    }
    ft_bzero(gc->ptr, size);
    gc->next = NULL;
    iter = *local_gc();
    if (!iter)
        *local_gc() = gc;
    else
    {
        while (iter->next)
            iter = iter->next;
        iter->next = gc;
    }
    return (gc->ptr);
}

void delete_(void *ptr)
{
    gc_t *iter;
    gc_t *prev;

    iter = *local_gc();
    prev = NULL;
    while (iter)
    {
        if (iter->ptr == ptr)
        {
            if (prev)
                prev->next = iter->next;
            else
                *local_gc() = iter->next;
            free(iter->ptr);
            free(iter);
            break;
        }
        prev = iter;
        iter = iter->next;
    }
}

void clean_()
{
    gc_t *iter;
    gc_t *next;

    iter = *local_gc();
    while (iter)
    {
        next = iter->next;
        free(iter->ptr);
        free(iter);
        iter = next;
    }
    *local_gc() = NULL;
}
#include "main.h"

scene_t *scene()
{
    static scene_t scene_;
    return (&scene_);
}

void print_scene_data()
{
    for (light_t *light_list = scene()->light_list; light_list; light_list = light_list->next)
    {
        printf(YELLOW"Light: \n"RESET);
        printf("\tpos: %f, %f, %f\n", light_list->pos.x, light_list->pos.y, light_list->pos.z);
        printf("\tbrightness: %f\n", light_list->brightness);
        printf("\tcolor: %d, %d, %d\n", light_list->color.r, light_list->color.g, light_list->color.b);
    }
}
# include "main.h"

void    **mlx()
{
    static void *mlx = NULL;

    return (&mlx);
}

void   **mlx_win()
{
    static void *win = NULL;

    return (&win);
}

t_data  *data()
{
    static t_data  data;

    return (&data);
}

void    flush()
{
    mlx_put_image_to_window(*mlx(), *mlx_win(), data()->img, 0, 0);
}
#include "main.h"

/**
    * A 0.2 255,255,255
    ∗ identifier: A
    ∗ ambient lighting ratio in range [0.0,1.0]: 0.2
    ∗ R,G,B colors in range [0-255]: 255, 255, 255
 */
ambient_light_t
*ambient_lighting_guard(char **split, int line)
{
    double           lighting_ratio;
    ambient_light_t *res;
    color_t         color;

    if (split_len(split) != 3)
       throw_error("Invalid arguments of ambient light in line: ", line, NULL);

    lighting_ratio = double_guard(split[1], line, 0, 1);
    (void)lighting_ratio;
    color = color_guard(split[2], line);

    res = new_(sizeof(ambient_light_t));
    res->lighting_ratio = lighting_ratio;
    res->color.r = color.r;
    res->color.g = color.g;
    res->color.b = color.b;
    res->next = NULL;

    // if (DEBUG)
    // {
    //     printf(YELLOW"Ambient Light: \n"RESET);
    //     printf("\tlighting_ratio: %f\n", res->lighting_ratio);
    //     printf("\tcolor: %d, %d, %d\n", res->color.r, res->color.g, res->color.b);
    // }

    insert_ambient_light(res);
    return (res);
}


/**
    * L -40.0,50.0,0.0 0.6 10,0,255
    ∗ identifier: L
    ∗ x,y,z coordinates of the light source: -40.0, 50.0, 0.0
    ∗ the light brightness ratio in range [0.0,1.0]: 0.6
    ∗ R,G,B colors in range [0-255]: 10, 0, 255
 */
light_t
*light_guard(char **split, int line)
{
    light_t *res;

    if (split_len(split) != 4)
        throw_error("Invalid light arguments at line: ", line, NULL);

    res = new_(sizeof(light_t));

    res->pos = point_guard(split[1], line);
    res->brightness = double_guard(split[2], line, 0, 1);
    res->color = color_guard(split[3], line);
    res->next = NULL;

    // if (DEBUG)
    // {
    //     printf(YELLOW"Light: \n"RESET);
    //     printf("\tpos: %f, %f, %f\n", res->pos.x, res->pos.y, res->pos.z);
    //     printf("\tbrightness: %f\n", res->brightness);
    //     printf("\tcolor: %d, %d, %d\n", res->color.r, res->color.g, res->color.b);
    // }

    insert_light(res);
    return res;
}#include "main.h"

/**
 * pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,225
 * identifier: pl
 * position of center: 0.0,0.0,-10.0
 * normalized orientation vector: 0.0,1.0,0.0
 * color: 0,0,225
 */
plane_t
*plane_guard(char **split, int line)
{
    plane_t *res;

    if (split_len(split) != 4)
        throw_error("Invalid plane arguments at line: ", line, NULL);

    res = new_(sizeof(plane_t));

    res->pos = point_guard(split[1], line);
    res->normal = point_guard(split[2], line);
    res->color = color_guard(split[3], line);

    res->next = NULL;

    // if (DEBUG)
    // {
    //     printf(YELLOW"Plane: \n"RESET);
    //     printf("\tpos: %f, %f, %f\n", res->pos.x, res->pos.y, res->pos.z);
    //     printf("\tnormal: %f, %f, %f\n", res->normal.x, res->normal.y, res->normal.z);
    //     printf("\tcolor: %d, %d, %d\n", res->color.r, res->color.g, res->color.b);
    // }

    insert_plane(res);
    return (res);
}
#include "main.h"

space_point_t   point_guard(char *str, int line)
{
    space_point_t res;
    char **split;

    split = ft_split(str, ",");

    if (split_len(split) != 3)
        throw_error("Invalid point arguments at line: ", line, str);

    res.x = double_guard(split[0], line, DOUBLE_MIN, DOUBLE_MAX);
    res.y = double_guard(split[1], line, DOUBLE_MIN, DOUBLE_MAX);
    res.z = double_guard(split[2], line, DOUBLE_MIN, DOUBLE_MAX);
    return (res);
}
#include "main.h"

void	put_pixel(int x, int y, int color)
{
	char	*dst;

	dst = data()->addr + (y * data()->line_length + x * (data()->bits_per_pixel / 8));
	*(unsigned int*)dst = color;
	printf("Pixel at %d, %d is %d\n", x, y, color);
}
#include "main.h"

bool    is_valid_extension(char *filename)
{
    char *ext;

    ext = ft_strrchr(filename, '.');
    if (!ext)
        return (false);
    if (ft_strncmp(ext, ".rt", ft_strlen(ext)) != 0)
        return (false);
    return (true);
}

/**
 * this function will guard items
 */
void    *guard(char **split, int line)
{
    if (ft_strncmp(split[0], "A", ft_strlen(split[0])) == 0)
        return ambient_lighting_guard(split, line);
    else if (ft_strncmp(split[0], "C", ft_strlen(split[0])) == 0)
    {
        if ((scene())->camera)
            throw_error("Multiple cameras: ", line, NULL);
        scene()->camera = camera_guard(split, line);
        return scene()->camera;
    }
    else if (ft_strncmp(split[0], "L", ft_strlen(split[0])) == 0)
        return light_guard(split, line);
    else if (ft_strncmp(split[0], "sp", ft_strlen(split[0])) == 0)
        return sphere_guard(split, line);
    else if (ft_strncmp(split[0], "pl", ft_strlen(split[0])) == 0)
        return plane_guard(split, line);
    else if (ft_strncmp(split[0], "cy", ft_strlen(split[0])) == 0)
        return cylander_guard(split, line);
    return (NULL);
}

/**
 * this function will process the line
 */
void    process_line(char *line, int line_count)
{
    char        **split;
    void        *item;

    line = ft_strtrim(line, "\n");

    if (ft_strlen(line) == 0)
        return (throw_error("Empty line: ", line_count, NULL));

    split = ft_split(line, " \t");
    if (!split)
        throw_error("Invalid line: ", line_count, NULL);

    item = guard(split, line_count);
    if (item)
        return ;
    throw_error("Invalid arguments at line: ", line_count, line); 
}

/**
 * this function will read line by line
 */
void read_map_data(char *filename)
{
    int     fd;
    char    *line;
    int     line_count;

    if (!is_valid_extension(filename))
        throw_error("Invalid file extension", -1, filename);
    fd = open(filename, O_RDONLY);
    if (fd < 0)
        throw_error("Can't open file", -1, filename);
    line_count = 1;
    line = get_next_line(fd);
    if (!line)
        throw_error("Empty file", -1, filename);
    while (line)
    {
        process_line(line, line_count);
        delete_(line);
        line = get_next_line(fd);
        line_count++;
    }
}
#include "main.h"

void    render()
{
    sphere_t    *sphere;

    // sphers check
    sphere = scene()->sphere_list;
    while (sphere)
    {
        if (is_in_fov(&sphere->pos))
            printf("Sphere-> {%f, %f, %f} will be rendered\n", sphere->pos.x, sphere->pos.y, sphere->pos.z);
        sphere = sphere->next;
    }
}
#include "main.h"

/**
 * sp 0.0,0.0,20.6 12.6 10,0,255
 * identifier: sp
 * position of center: 0.0,0.0,20.6
 * diameter: 12.6
 * color: 10,0,255
*/
sphere_t
*sphere_guard(char **split, int line_count)
{
    sphere_t *res;

    if (split_len(split) != 4)
        throw_error("Invalid sphere arguments at line: ", line_count, NULL);

    res = new_(sizeof(sphere_t));

    res->pos = point_guard(split[1], line_count);
    res->diameter = double_guard(split[2], line_count, DOUBLE_MIN, DOUBLE_MAX);
    res->color = color_guard(split[3], line_count);

    res->next = NULL;

    // if (DEBUG)
    // {
    //     printf(YELLOW"Sphere: \n"RESET);
    //     printf("\tpos: %f, %f, %f\n", res->pos.x, res->pos.y, res->pos.z);
    //     printf("\tdiameter: %f\n", res->diameter);
    //     printf("\tcolor: %d, %d, %d\n", res->color.r, res->color.g, res->color.b);
    // }

    insert_sphere(res);
    return (res);
}
#include "main.h"

int
split_len(char **split)
{
    int i;

    if (!split)
        return 0;
    i = 0;
    while (split[i])
        i++;
    return i;
}

double
double_guard(char *arg, int line, double min, double max)
{
    double   left;
    double   right;
    char    **lighting_ratio;
    double   res;

    if (ft_strlen(arg) < 3 || !ft_strchr(arg, '.'))
    {
        res = (double)ft_atoi(arg);
        if (res < min || res > max)
            throw_error("Value out of range in line: ", line, arg);
        return res;
    }

    res = .0;
    lighting_ratio = ft_split(arg, ".");
    left = ft_atoi(lighting_ratio[0]);
    right = ft_atoi(lighting_ratio[1]);
    if ((left > max) || (left == max && right != 0))
        throw_error("Value out of range in line: ", line, arg);
    if (left < min)
        throw_error("Value out of range in line: ", line, arg);
    res += left;
    res += (double)((right) * pow(10, -(ft_intlen(right))));
    return res;
}
#include "main.h"

void insert_light(light_t *light)
{
    light_t *light_node;

    light_node = scene()->light_list;

    if (!light_node)
    {
        scene()->light_list = light;
        return ;
    }

    while (light_node->next)
        light_node = light_node->next;

    light_node->next = light;
}

void insert_ambient_light(ambient_light_t *a_light)
{
    ambient_light_t *a_light_node;

    a_light_node = scene()->ambient_light_list;

    if (!a_light_node)
    {
        scene()->ambient_light_list = a_light;
        return ;
    }

    while (a_light_node->next)
        a_light_node = a_light_node->next;

    a_light_node->next = a_light;
}

void insert_cylinder(cylinder_t *cylinder)
{
    cylinder_t *cylinder_node;

    cylinder_node = scene()->cylinder_list;

    if (!cylinder_node)
    {
        scene()->cylinder_list = cylinder;
        return ;
    }

    while (cylinder_node->next)
        cylinder_node = cylinder_node->next;

    cylinder_node->next = cylinder;
}

void insert_plane(plane_t *plane)
{
    plane_t *plane_node;

    plane_node = scene()->plane_list;

    if (!plane_node)
    {
        scene()->plane_list = plane;
        return ;
    }

    while (plane_node->next)
        plane_node = plane_node->next;

    plane_node->next = plane;
}

void insert_sphere(sphere_t *sphere)
{
    sphere_t *sphere_node;

    sphere_node = scene()->sphere_list;

    if (!sphere_node)
    {
        scene()->sphere_list = sphere;
        return ;
    }

    while (sphere_node->next)
        sphere_node = sphere_node->next;

    sphere_node->next = sphere;
}
